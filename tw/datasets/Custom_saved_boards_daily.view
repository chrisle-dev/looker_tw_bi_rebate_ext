view: custom_saved_boards_daily {
  derived_table: {
    sql:
    select *,
    coalesce(cast(max(version_number) over(partition by custom_view_name_root) as int64),0) as latest_version
    FROM
    (SELECT *,
    greatest(cast(section_updated_at as timestamp), cast(board_item_updated_at as timestamp)) as last_updated,
    REGEXP_EXTRACT(section_title, r'v(?:ersion)?(\d+)') AS version_number,
    case when lower(section_title) like "%delete%" then "yes" else "no" end as is_deleted,
    REGEXP_REPLACE(section_title, r'(_?v(?:ersion)?\d+.*$)', '') AS custom_view_name_root
    FROM (select * from `da-dev-430905.Rebate_TW_saved_boards.Custom_saved_boards_daily`) tb1
    left join
    (select board_item_url, board_id, min(approved_date) as first_approved_date from
    (SELECT URL as board_item_url ,cast(`Board ID` as string) as board_id,  PARSE_DATE( '%m/%d/%Y', `Approved Date`) as approved_date FROM `da-dev-430905.Rebate_TW_saved_boards.Approved_custom_views_daily` )
    where approved_date is not null
    group by 1,2) tb2 using (board_item_url, board_id)
    )
;;
  }

  dimension: board_id {
    type: string
    sql: ${TABLE}.board_id ;;
  }

  dimension: user {
    type: string
    sql: ${TABLE}.board_item_created_by ;;
  }
  dimension: view_name {
    type: string
    sql: ${TABLE}.section_title ;;
  }
  dimension: latest_version {
    type: number
    sql: ${TABLE}.latest_version ;;
  }
  dimension: last_update_date {
    type: date
    sql: cast(${TABLE}.last_updated as date) ;;
  }
  dimension: approved_date {
    type: string
    sql: ${TABLE}.first_approved_date ;;
  }
  dimension: url {
    type: string
    sql: ${TABLE}.board_item_url ;;
    link: {
      label: "Click here"
      url: "https://lookerdev.zuelligpharma.com{{value}}"
    }
  }
  dimension: status {
    type: string
    sql: case when lower(${view_name}) like "%delete%" then "Cancelled"
              when lower(${view_name}) like "%for%approval%" and ${approved_date} is null and ${TABLE}.version_number = cast(${latest_version} as string) then "Sent for Approval"
              when lower(${view_name}) like "%for%approval%" and ${approved_date} is not null then "NKAM Approved"
              else "In Preparation"
        end
    ;;
  }
  dimension: action {
    type: string
    sql: case when lower(${view_name}) like "%delete%" then "MAA/KAM to verify cancelled rebate"
              when lower(${view_name}) like "%for%approval%" and ${approved_date} is null and ${TABLE}.version_number = cast(${latest_version} as string) then "NKAM to approve"
              when lower(${view_name}) like "%for%approval%" and ${approved_date} is not null then ""
              else "KAM to get hospital agreement"
        end
          ;;
  }
}

# view: custom_saved_boards_daily {
#   # Or, you could make this view a derived table, like this:
#   derived_table: {
#     sql: SELECT
#         user_id as user_id
#         , COUNT(*) as lifetime_orders
#         , MAX(orders.created_at) as most_recent_purchase_at
#       FROM orders
#       GROUP BY user_id
#       ;;
#   }
#
#   # Define your dimensions and measures here, like this:
#   dimension: user_id {
#     description: "Unique ID for each user that has ordered"
#     type: number
#     sql: ${TABLE}.user_id ;;
#   }
#
#   dimension: lifetime_orders {
#     description: "The total number of orders for each user"
#     type: number
#     sql: ${TABLE}.lifetime_orders ;;
#   }
#
#   dimension_group: most_recent_purchase {
#     description: "The date when each user last ordered"
#     type: time
#     timeframes: [date, week, month, year]
#     sql: ${TABLE}.most_recent_purchase_at ;;
#   }
#
#   measure: total_lifetime_orders {
#     description: "Use this for counting lifetime orders across many users"
#     type: sum
#     sql: ${lifetime_orders} ;;
#   }
# }
